service: hb-file-processing

# IMPORTANT: After deploying, run ./scripts/configure-s3-cors.sh
# Or use: npm run deploy:full  or  make deploy-full
# See DEPLOYMENT.md for details

frameworkVersion: "3"

# Load variables from local .env / .env.* files so ${env:...} works in all commands
useDotenv: true

plugins:
  - serverless-offline
  - serverless-python-requirements

package:
  individually: false
  patterns:
    - '!node_modules/**'
    - '!__pycache__/**'
    - '!.pytest_cache/**'
    - '!tests/**'
    - '!layer-shared/**'

custom:
  # Single environment (no -dev / -prod suffixes)
  # Bucket name must be globally unique, so we add the AWS account ID
  uploadBucket: hb-files-raw
  filesTable: hb-files
  catalogProductsTable: hb-catalog-products
  productsTable: hb-products
  priceListProductsTable: hb-pricelist-products
  # Production frontend URL (change this when deploying to production)
  productionFrontendUrl: ${env:PRODUCTION_FRONTEND_URL, 'https://catalog-searcher-omers-projects-e3a112ba.vercel.app'}

provider:
  name: aws
  runtime: python3.11
  region: us-east-1
  stage: dev                 # internal only, not used in resource names
  profile: hb-client
  deploymentBucket:
    name: hb-file-processing-deployment-bucket
    blockPublicAccess: true

  httpApi:
    cors:
      allowedOrigins:
        - "http://localhost:3000"
        - "http://localhost:3001"
        - "${self:custom.productionFrontendUrl}"
      allowedHeaders:
        - Content-Type
        - Authorization
        - X-Requested-With
        - X-Amz-Date
        - X-Api-Key
        - X-Amz-Security-Token
      allowedMethods:
        - GET
        - POST
        - PUT
        - DELETE
        - OPTIONS
      allowCredentials: true  # Required for Cognito tokens
      maxAge: 3600
      exposedResponseHeaders:
        - Content-Type
        - X-Amz-Date
        - X-Amz-Request-Id
    # JWT Authorizer (built-in, simpler than Lambda authorizer)
    # Note: Authorizer requires COGNITO_USER_POOL_ID and COGNITO_APP_CLIENT_ID from .env
    authorizers:
      cognitoAuthorizer:
        identitySource: $request.header.Authorization
        issuerUrl: https://cognito-idp.${self:provider.region}.amazonaws.com/${env:COGNITO_USER_POOL_ID, ''}
        audience:
          - ${env:COGNITO_APP_CLIENT_ID, ''}

  environment:
    UPLOAD_BUCKET: ${self:custom.uploadBucket}
    FILES_TABLE: ${self:custom.filesTable}
    CATALOG_PRODUCTS_TABLE: ${self:custom.catalogProductsTable}
    PRODUCTS_TABLE: ${self:custom.productsTable}
    PRICE_LIST_PRODUCTS_TABLE: ${self:custom.priceListProductsTable}
    # PYTHONPATH: layer path for local dev (serverless-offline) and Lambda (/opt/python is auto-added in Lambda)
    PYTHONPATH: "layer-shared/python:/opt/python"
    # AWS Configuration for local development
    # Note: AWS_PROFILE is only set if explicitly provided via env var (for local dev)
    # In real Lambda, we use IAM roles, so AWS_PROFILE should not be set
    AWS_PROFILE: ${env:AWS_PROFILE, ''}
    
    # Cognito Configuration (optional - for JWT authorizer)
    COGNITO_USER_POOL_ID: ${env:COGNITO_USER_POOL_ID, ''}
    COGNITO_APP_CLIENT_ID: ${env:COGNITO_APP_CLIENT_ID, ''}
    COGNITO_REGION: ${env:COGNITO_REGION, 'us-east-1'}
    
    # Frontend URL for CORS
    PRODUCTION_FRONTEND_URL: ${self:custom.productionFrontendUrl}

  iamRoleStatements:
    # S3 access for generating presigned URLs and accessing uploaded files
    - Effect: Allow
      Action:
        - s3:PutObject
        - s3:GetObject
        - s3:DeleteObject
        - s3:ListBucket
      Resource:
        - arn:aws:s3:::${self:custom.uploadBucket}
        - arn:aws:s3:::${self:custom.uploadBucket}/*

    # DynamoDB access for Files, CatalogProducts, Products, and PriceListProducts tables
    - Effect: Allow
      Action:
        - dynamodb:PutItem
        - dynamodb:GetItem
        - dynamodb:UpdateItem
        - dynamodb:DeleteItem
        - dynamodb:Query
        - dynamodb:Scan
        - dynamodb:BatchGetItem
        - dynamodb:BatchWriteItem
      Resource:
        - arn:aws:dynamodb:${self:provider.region}:*:table/${self:custom.filesTable}
        - arn:aws:dynamodb:${self:provider.region}:*:table/${self:custom.catalogProductsTable}
        - arn:aws:dynamodb:${self:provider.region}:*:table/${self:custom.productsTable}
        - arn:aws:dynamodb:${self:provider.region}:*:table/${self:custom.productsTable}/index/*
        - arn:aws:dynamodb:${self:provider.region}:*:table/${self:custom.priceListProductsTable}

    # Textract permissions (for PDFs)
    - Effect: Allow
      Action:
        - textract:StartDocumentAnalysis
        - textract:GetDocumentAnalysis
      Resource: "*"
    
    # Secrets Manager access for API keys
    - Effect: Allow
      Action:
        - secretsmanager:GetSecretValue
        - secretsmanager:DescribeSecret
      Resource:
        - arn:aws:secretsmanager:${self:provider.region}:*:secret:file-ingestion-api-key-*
        - arn:aws:secretsmanager:${self:provider.region}:*:secret:quotation-api-key-*
        - arn:aws:secretsmanager:${self:provider.region}:*:secret:product-search-api-key-*

layers:
  shared:
    path: layer-shared
    name: ${self:service}-${self:provider.stage}-shared
    description: Shared package layer
    compatibleRuntimes:
      - python3.11
    retain: false

functions:
  # HTTP API for UI -> get presigned URL to upload file to S3
  getPresignedUrl:
    handler: src/get_presigned_url.get_presigned_url
    layers:
      - { Ref: SharedLambdaLayer }
    events:
      - httpApi:
          path: /api/files/presigned-url
          method: post

  # HTTP API for UI -> generate presigned download URL (client supplies S3 key)
  getFileDownloadUrl:
    handler: src/get_files.get_file_download_url
    layers:
      - { Ref: SharedLambdaLayer }
    events:
      - httpApi:
          path: /api/files/download-url
          method: post
          
  # HTTP API for UI -> get file information after upload
  getFileInfo:
    handler: src/get_files.get_file_info
    layers:
      - { Ref: SharedLambdaLayer }
    events:
      - httpApi:
          path: /api/files/{fileId}
          method: get

  # HTTP API for UI -> get all files
  getFiles:
    handler: src/get_files.get_files
    layers:
      - { Ref: SharedLambdaLayer }
    events:
      - httpApi:
          path: /api/files
          method: get

  
  # HTTP API for UI -> delete a file
  deleteFile:
    handler: src/get_files.delete_file
    layers:
      - { Ref: SharedLambdaLayer }
    events:
      - httpApi:
          path: /api/files/{fileId}
          method: delete


  # HTTP API for UI -> get catalog products extracted from a file
  getCatalogProducts:
    handler: src/get_files.get_catalog_products
    layers:
      - { Ref: SharedLambdaLayer }
    events:
      - httpApi:
          path: /api/files/{fileId}/catalog-products
          method: get

  # HTTP API for UI -> get price list products extracted from a file
  getPriceListProducts:
    handler: src/get_files.get_price_list_products
    layers:
      - { Ref: SharedLambdaLayer }
    events:
      - httpApi:
          path: /api/files/{fileId}/price-list-products
          method: get

  # HTTP API for UI -> update catalog products after review
  updateCatalogProducts:
    handler: src/get_files.update_catalog_products
    layers:
      - { Ref: SharedLambdaLayer }
    events:
      - httpApi:
          path: /api/files/{fileId}/catalog-products
          method: put

  # HTTP API for UI -> update price list products after review
  updatePriceListProducts:
    handler: src/get_files.update_price_list_products
    timeout: 25  # Extended timeout for large price list updates (5558 products)
    layers:
      - { Ref: SharedLambdaLayer }
    events:
      - httpApi:
          path: /api/files/{fileId}/price-list-products
          method: put

  # HTTP API for UI -> check if a file already exists
  checkFileExists:
    handler: src/get_files.check_file_exists
    layers:
      - { Ref: SharedLambdaLayer }
    events:
      - httpApi:
          path: /api/files/check-file-exists
          method: post

  # HTTP API for UI -> complete file review (mark as completed)
  completeFileReview:
    handler: src/get_files.complete_file_review
    layers:
      - { Ref: SharedLambdaLayer }
    events:
      - httpApi:
          path: /api/files/{fileId}/complete
          method: put

  # HTTP API for UI -> check existing products by ordering numbers
  checkExistingProducts:
    handler: src/get_files.check_existing_products
    layers:
      - { Ref: SharedLambdaLayer }
    events:
      - httpApi:
          path: /api/products/check-existing
          method: post

  # HTTP API for UI -> save products from catalog to products table
  saveProductsFromCatalog:
    handler: src/get_files.save_products_from_catalog
    layers:
      - { Ref: SharedLambdaLayer }
    events:
      - httpApi:
          path: /api/products/from-catalog
          method: post

  # HTTP API for UI -> save products from price list to products table
  saveProductsFromPriceList:
    handler: src/get_files.save_products_from_price_list
    timeout: 120  # Extended timeout for saving thousands of products with batch writes
    layers:
      - { Ref: SharedLambdaLayer }
    events:
      - httpApi:
          path: /api/products/from-price-list
          method: post

  # HTTP API for UI -> link sales drawing to product
  saveSalesDrawingToProduct:
    handler: src/get_files.save_sales_drawing_to_product
    layers:
      - { Ref: SharedLambdaLayer }
    events:
      - httpApi:
          path: /api/products/sales-drawing
          method: post

  unlinkSalesDrawingFromProduct:
    handler: src/get_files.unlink_sales_drawing_from_product
    layers:
      - { Ref: SharedLambdaLayer }
    events:
      - httpApi:
          path: /api/products/unlink-sales-drawing
          method: post

  listProducts:
    handler: src/get_files.list_products
    layers:
      - { Ref: SharedLambdaLayer }
    events:
      - httpApi:
          path: /api/products
          method: get

  # Triggered whenever a file is uploaded to the bucket (via presigned URL)
  processUploadedFile:
    handler: src/process_upload_file.process_uploaded_file
    timeout: 45  # 5 minutes for Textract processing
    layers:
      - { Ref: SharedLambdaLayer }
    events:
      - s3:
          bucket: ${self:custom.uploadBucket}
          event: s3:ObjectCreated:*
          existing: false

resources:
  Resources:
    # SOLUTION 1: Don't override - let Serverless Framework manage the bucket
    # Configure CORS via AWS CLI script after deployment (see scripts/configure-s3-cors.sh)
    # This is the simplest approach that avoids CloudFormation conflicts
    
    FilesTable:
      Type: AWS::DynamoDB::Table
      Properties:
        TableName: ${self:custom.filesTable}
        BillingMode: PAY_PER_REQUEST
        AttributeDefinitions:
          - AttributeName: fileId
            AttributeType: S
        KeySchema:
          - AttributeName: fileId
            KeyType: HASH

    CatalogProductsTable:
      Type: AWS::DynamoDB::Table
      Properties:
        TableName: ${self:custom.catalogProductsTable}
        BillingMode: PAY_PER_REQUEST
        AttributeDefinitions:
          - AttributeName: fileId
            AttributeType: S
        KeySchema:
          - AttributeName: fileId
            KeyType: HASH

    ProductsTable:
      Type: AWS::DynamoDB::Table
      Properties:
        TableName: ${self:custom.productsTable}
        BillingMode: PAY_PER_REQUEST
        AttributeDefinitions:
          - AttributeName: orderingNumber
            AttributeType: S
          - AttributeName: productCategory
            AttributeType: S
        KeySchema:
          - AttributeName: orderingNumber
            KeyType: HASH
        GlobalSecondaryIndexes:
          - IndexName: ProductCategoryIndex
            KeySchema:
              - AttributeName: productCategory
                KeyType: HASH
            Projection:
              ProjectionType: ALL
        StreamSpecification:
          StreamViewType: NEW_AND_OLD_IMAGES
              
    PriceListProductsTable:
      Type: AWS::DynamoDB::Table
      Properties:
        TableName: ${self:custom.priceListProductsTable}
        BillingMode: PAY_PER_REQUEST
        AttributeDefinitions:
          - AttributeName: fileId
            AttributeType: S
          - AttributeName: chunkIndex
            AttributeType: N
        KeySchema:
          - AttributeName: fileId
            KeyType: HASH
          - AttributeName: chunkIndex
            KeyType: RANGE

  Outputs:
    ProductsTableStreamArn:
      Description: DynamoDB Stream ARN for Products Table
      Value:
        Fn::GetAtt:
          - ProductsTable
          - StreamArn
      Export:
        Name: ${self:service}-${self:provider.stage}-products-table-stream-arn
